import random
from itertools import repeat
import collections.abc
import numpy as np
import yaml
import os
import torch
import math
import struct


def set_seed(seed=1777):
    random.seed(seed)
    np.random.seed(seed)
    os.environ['PYTHONHASHSEED'] = str(seed)
    torch.manual_seed(seed)
    torch.cuda.manual_seed(seed)
    torch.cuda.manual_seed_all(seed) # if use multi-GPU
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = False
    print(f"seed : {seed}")

def get_config(config):
    with open(config, 'r') as stream:
        return yaml.load(stream, Loader=yaml.FullLoader)

def ensure_dir(path):
    """
    create path by first checking its existence,
    :param paths: path
    :return:
    """
    if not os.path.exists(path):
        print("Create folder ", path)
        os.makedirs(path)
    else:
        print(path, " already exists.")

def ensure_dirs(paths):
    """
    create paths by first checking their existence
    :param paths: list of path
    :return:
    """
    if isinstance(paths, list) and not isinstance(paths, str):
        for path in paths:
            ensure_dir(path)
    else:
        ensure_dir(paths)

def print_composite(data, beg=""):
    if isinstance(data, dict):
        print(f'{beg} dict, size = {len(data)}')
        for key, value in data.items():
            print(f'  {beg}{key}:')
            print_composite(value, beg + "    ")
    elif isinstance(data, list):
        print(f'{beg} list, len = {len(data)}')
        for i, item in enumerate(data):
            print(f'  {beg}item {i}')
            print_composite(item, beg + "    ")
    elif isinstance(data, np.ndarray) or isinstance(data, torch.Tensor):
        print(f'{beg} array of size {data.shape}')
    else:
        print(f'{beg} {data}')

def get_model_list(dirname, key):
    if os.path.exists(dirname) is False:
        return None
    gen_models = [os.path.join(dirname, f) for f in os.listdir(dirname) if
                  os.path.isfile(os.path.join(dirname, f)) and
                  key in f and ".pt" in f]
    if gen_models is None or len(gen_models) == 0:
        return None
    gen_models.sort()
    last_model_name = gen_models[-1]
    return last_model_name

# From PyTorch internals
def _ntuple(n):
    def parse(x):
        if isinstance(x, collections.abc.Iterable):
            return x
        return tuple(repeat(x, n))
    return parse


to_1tuple = _ntuple(1)
to_2tuple = _ntuple(2)
to_3tuple = _ntuple(3)
to_4tuple = _ntuple(4)
to_ntuple = _ntuple


def make_divisible(v, divisor=8, min_value=None, round_limit=.9):
    min_value = min_value or divisor
    new_v = max(min_value, int(v + divisor / 2) // divisor * divisor)
    # Make sure that round down does not go down by more than 10%.
    if new_v < round_limit * v:
        new_v += divisor
    return new_v

def trunc_normal_(tensor, mean=0., std=1., a=-2., b=2.):
    # type: (Tensor, float, float, float, float) -> Tensor
    return _no_grad_trunc_normal_(tensor, mean, std, a, b)


def _no_grad_trunc_normal_(tensor, mean, std, a, b):
    # Cut & paste from PyTorch official master until it's in a few official releases - RW
    # Method based on https://people.sc.fsu.edu/~jburkardt/presentations/truncated_normal.pdf
    def norm_cdf(x):
        # Computes standard normal cumulative distribution function
        return (1. + math.erf(x / math.sqrt(2.))) / 2.

    if (mean < a - 2 * std) or (mean > b + 2 * std):
        warnings.warn("mean is more than 2 std from [a, b] in nn.init.trunc_normal_. "
                      "The distribution of values may be incorrect.",
                      stacklevel=2)

    with torch.no_grad():
        # Values are generated by using a truncated uniform distribution and
        # then using the inverse CDF for the normal distribution.
        # Get upper and lower cdf values
        l = norm_cdf((a - mean) / std)
        u = norm_cdf((b - mean) / std)

        # Uniformly fill tensor with values from [l, u], then translate to
        # [2l-1, 2u-1].
        tensor.uniform_(2 * l - 1, 2 * u - 1)

        # Use inverse cdf transform for normal distribution to get truncated
        # standard normal
        tensor.erfinv_()

        # Transform to proper mean, std
        tensor.mul_(std * math.sqrt(2.))
        tensor.add_(mean)

        # Clamp to ensure it's in the proper range
        tensor.clamp_(min=a, max=b)
        return tensor


def load_database(filename):

    with open(filename, 'rb') as f:
        nframes, nbones = struct.unpack('II', f.read(8))
        bone_positions = np.frombuffer(f.read(nframes*nbones*3*4), dtype=np.float32, count=nframes*nbones*3).reshape([nframes, nbones, 3])
        
        nframes, nbones = struct.unpack('II', f.read(8))
        bone_velocities = np.frombuffer(f.read(nframes*nbones*3*4), dtype=np.float32, count=nframes*nbones*3).reshape([nframes, nbones, 3])
        
        nframes, nbones = struct.unpack('II', f.read(8))
        bone_rotations = np.frombuffer(f.read(nframes*nbones*4*4), dtype=np.float32, count=nframes*nbones*4).reshape([nframes, nbones, 4])
        
        nframes, nbones = struct.unpack('II', f.read(8))
        bone_angular_velocities = np.frombuffer(f.read(nframes*nbones*3*4), dtype=np.float32, count=nframes*nbones*3).reshape([nframes, nbones, 3])
        
        nbones = struct.unpack('I', f.read(4))[0]
        bone_parents = np.frombuffer(f.read(nbones*4), dtype=np.int32, count=nbones).reshape([nbones])
        
        nranges = struct.unpack('I', f.read(4))[0]
        range_starts = np.frombuffer(f.read(nranges*4), dtype=np.int32, count=nranges).reshape([nranges])
        
        nranges = struct.unpack('I', f.read(4))[0]
        range_stops = np.frombuffer(f.read(nranges*4), dtype=np.int32, count=nranges).reshape([nranges])
        
        nstyles = struct.unpack('I', f.read(4))[0]
        style_labels = np.frombuffer(f.read(nstyles*4), dtype=np.int32, count=nstyles).reshape([nstyles])

        # nactions = struct.unpack('I', f.read(4))[0]
        # action_labels = np.frombuffer(f.read(nactions*4), dtype=np.int32, count=nactions).reshape([nactions])
        ncontents = struct.unpack('I', f.read(4))[0]
        content_labels = np.frombuffer(f.read(ncontents*4), dtype=np.int32, count=ncontents).reshape([ncontents])

        nframes, ncontacts = struct.unpack('II', f.read(8))
        contact_states = np.frombuffer(f.read(nframes*ncontacts), dtype=np.int8, count=nframes*ncontacts).reshape([nframes, ncontacts])
        
    return {
        'bone_positions': bone_positions,
        'bone_rotations': bone_rotations,
        'bone_velocities': bone_velocities,
        'bone_angular_velocities': bone_angular_velocities,
        'bone_parents': bone_parents,
        'range_starts': range_starts,
        'range_stops': range_stops,
        'style_labels': style_labels,
        'content_labels': content_labels,
        'contact_states': contact_states,
    } 

def load_features(filename):

    with open(filename, 'rb') as f:
        
        nframes, nfeatures = struct.unpack('II', f.read(8))
        features = np.frombuffer(f.read(nframes*nfeatures*4), dtype=np.float32, count=nframes*nfeatures).reshape([nframes, nfeatures])
        
        nfeatures = struct.unpack('I', f.read(4))[0]
        features_offset = np.frombuffer(f.read(nfeatures*4), dtype=np.float32, count=nfeatures).reshape([nfeatures])
        
        nfeatures = struct.unpack('I', f.read(4))[0]
        features_scale = np.frombuffer(f.read(nfeatures*4), dtype=np.float32, count=nfeatures).reshape([nfeatures])
        
    return {
        'features': features,
        'features_offset': features_offset,
        'features_scale': features_scale,
    }